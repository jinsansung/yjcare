<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <title>YJCARE Monitor</title>
  <style>
    :root{
      --bg:#000000;
      --text:#f4f4f7;
      --muted:rgba(244,244,247,0.68);
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; background:var(--bg); overflow:hidden;}
    body{
      font-family:-apple-system, system-ui, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }

    /* 배경 그래프 캔버스 */
    #bgCanvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
    }

    /* 중앙 오버레이 */
    .overlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 12px;
      pointer-events:none;
    }
    .panel{
      width:100%;
      max-width: 900px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: 10px;
      text-align:center;
    }

    .mainRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 18px;
      width:100%;
    }

    .bg{
      font-size: 192px;
      line-height: 0.92;
      font-weight: 850;
      letter-spacing: -2.2px;
      color: var(--text);
      text-align:center;
    }

    /* 공용 롤(슈루룩) 스택 */
    .numStack{
      position:relative;
      display:inline-block;
      height: 1em;
      overflow:hidden;
      width: 100%;
    }
    .num{
      position:absolute;
      left:0;
      right:0;
      text-align:center;
      will-change: transform, opacity;
      transform: translateY(0);
      opacity: 1;
    }
    .num.new{ opacity:0; }

    .numStack.anim-up .old{
      transform: translateY(-115%);
      opacity:0;
      transition: transform 420ms cubic-bezier(.22,.61,.36,1), opacity 420ms cubic-bezier(.22,.61,.36,1);
    }
    .numStack.anim-up .new{
      transform: translateY(0);
      opacity:1;
      transition: transform 420ms cubic-bezier(.22,.61,.36,1), opacity 420ms cubic-bezier(.22,.61,.36,1);
    }

    .numStack.anim-down .old{
      transform: translateY(115%);
      opacity:0;
      transition: transform 420ms cubic-bezier(.22,.61,.36,1), opacity 420ms cubic-bezier(.22,.61,.36,1);
    }
    .numStack.anim-down .new{
      transform: translateY(0);
      opacity:1;
      transition: transform 420ms cubic-bezier(.22,.61,.36,1), opacity 420ms cubic-bezier(.22,.61,.36,1);
    }

    .arrow{
      font-size: 88px;
      font-weight: 850;
      letter-spacing: -1px;
      color: var(--muted);
      min-width: 96px;
      text-align:center;
      line-height: 1;
      white-space:nowrap;
      transform: translateY(2px);
    }
    .arrow.up{ color: rgba(255,92,92,0.95); }
    .arrow.down{ color: rgba(110,231,183,0.95); }
    .arrow.flat{ color: rgba(244,244,247,0.68); }

    .subRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 22px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.2px;
      line-height: 1.25;
    }
    .subRow span b{
      color: var(--text);
      font-weight: 800;
    }

    /* 초소형 모니터 대응 */
    @media (max-width: 520px){
      .bg{ font-size: 156px; }
      .arrow{ font-size: 74px; min-width: 84px; }
      .subRow{ font-size: 20px; gap: 16px; }
      .panel{ gap: 8px; }
    }
    @media (max-height: 240px){
      .bg{ font-size: 148px; }
      .arrow{ font-size: 68px; }
      .subRow{ font-size: 18px; gap: 14px; }
      .panel{ gap: 6px; }
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas" width="1200" height="600"></canvas>

  <div class="overlay">
    <div class="panel">
      <div class="mainRow">
        <div id="bgTxt" class="bg">
          <span class="numStack" id="numStackBg">
            <span id="bgOld" class="num old">--</span>
            <span id="bgNew" class="num new">--</span>
          </span>
        </div>

        <div id="arrowWrap" class="arrow flat">
          <span class="numStack" id="numStackArrow">
            <span id="arrowOld" class="num old">—</span>
            <span id="arrowNew" class="num new">—</span>
          </span>
        </div>
      </div>

      <div class="subRow">
        <span><b id="ageTxt">--:--</b> (<b id="chgTxt">--</b>)</span>
        <span>IOB <b id="iobTxt">--</b>U</span>
        <span>COB <b id="cobTxt">--</b>g</span>
      </div>
    </div>
  </div>

<script>
/* ===== 설정 ===== */
const NS_BASE_URL = "https://ns.whalesound.net";
const NS_TOKEN = ""; // 옵션

/* ===== 유틸 ===== */
function withToken(url){
  if (!NS_TOKEN) return url;
  const hasQ = url.includes("?");
  return url + (hasQ ? "&" : "?") + "token=" + encodeURIComponent(NS_TOKEN);
}
async function fetchJson(url){
  const res = await fetch(url, { method:"GET" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}
function safeNum(x, fallback=null){
  const n = Number(x);
  return Number.isFinite(n) ? n : fallback;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function getSgv(e){
  return safeNum(e?.sgv, null) ?? safeNum(e?.mbg, null);
}
function sortByTimeDesc(arr){
  return [...arr].sort((a,b)=>safeNum(b.date,0)-safeNum(a.date,0));
}
function pad2(n){ return String(n).padStart(2, "0"); }

/* 경과시간 mm:ss (1시간 이상이면 h:mm:ss) */
function formatAge(ms){
  if (!Number.isFinite(ms) || ms < 0) return "--:--";
  const s = Math.floor(ms / 1000);
  const hh = Math.floor(s / 3600);
  const mm = Math.floor((s % 3600) / 60);
  const ss = s % 60;
  if (hh > 0) return `${hh}:${pad2(mm)}:${pad2(ss)}`;
  return `${mm}:${pad2(ss)}`;
}

/* ===== direction -> 화살표 ===== */
function directionToArrow(dirRaw){
  const dir = (dirRaw || "").toString().trim();
  const key = dir.toLowerCase();

  if (!dir || key === "none" || key === "flat" || key === "notcomputable" || key === "rateoutofrange"){
    return { arrow: "—", cls: "flat" };
  }

  const map = {
    "doubleup": { arrow: "↑↑", cls: "up" },
    "singleup": { arrow: "↑", cls: "up" },
    "fortyfiveup": { arrow: "↗", cls: "up" },

    "doubledown": { arrow: "↓↓", cls: "down" },
    "singledown": { arrow: "↓", cls: "down" },
    "fortyfivedown": { arrow: "↘", cls: "down" }
  };

  if (map[key]) return map[key];

  const compact = key.replace(/\s+/g, "");
  if (map[compact]) return map[compact];

  return { arrow: "—", cls: "flat" };
}

/* ===== 프로파일(필요 최소: dia, carbs_hr) ===== */
function pickProfileRecord(profileArr){
  if (!Array.isArray(profileArr) || profileArr.length === 0) return null;
  return [...profileArr].sort((a,b) => (Date.parse(b.created_at||b.startDate||0)||0) - (Date.parse(a.created_at||a.startDate||0)||0))[0];
}
function getActiveStore(profileRecord){
  if (!profileRecord) return null;
  const store = profileRecord.store || profileRecord;
  if (!store) return null;
  const defName = profileRecord.defaultProfile || store.defaultProfile || profileRecord.defaultprofile;
  if (defName && store[defName]) return store[defName];
  if (store.Default) return store.Default;
  const keys = Object.keys(store).filter(k => typeof store[k] === "object");
  return keys.length ? store[keys[0]] : null;
}
function getDiaAndCarbsHr(profileJson){
  const rec = pickProfileRecord(profileJson);
  const store = getActiveStore(rec);
  if (!store) return { dia: null, carbsHr: null };
  const dia = safeNum(store.dia, null) ?? safeNum(rec?.dia, null);
  const carbsHr = safeNum(store.carbs_hr, null) ?? safeNum(store.carbsHr, null);
  return { dia, carbsHr };
}

/* ===== IOB smootherstep ===== */
function insulinRemainingFractionSmootherstep(dtMs, diaHours){
  const diaMs = diaHours * 3600 * 1000;
  if (diaMs <= 0) return 0;
  const u = clamp01(dtMs / diaMs);
  const u2 = u*u;
  const u3 = u2*u;
  const f = u3 * (10 - 15*u + 6*u2);
  return 1 - f;
}
function computeIOB(treatments, atMs, diaHours){
  let iob = 0;
  for (const tr of treatments){
    const tMs = safeNum(tr.date, null) ?? Date.parse(tr.created_at || "");
    if (!Number.isFinite(tMs)) continue;
    const insulin = safeNum(tr.insulin, null);
    if (insulin === null || insulin <= 0) continue;
    const dt = atMs - tMs;
    if (dt < 0) continue;
    const frac = insulinRemainingFractionSmootherstep(dt, diaHours);
    if (frac <= 0) continue;
    iob += insulin * frac;
  }
  return iob;
}

/* ===== COB 선형 decay ===== */
function computeCOB(treatments, atMs, carbsHr){
  let cob = 0;
  for (const tr of treatments){
    const tMs = safeNum(tr.date, null) ?? Date.parse(tr.created_at || "");
    if (!Number.isFinite(tMs)) continue;
    const carbs = safeNum(tr.carbs, null) ?? safeNum(tr.carb, null);
    if (carbs === null || carbs <= 0) continue;
    const dtH = (atMs - tMs) / (3600 * 1000);
    if (dtH < 0) continue;
    const remain = carbs - carbsHr * dtH;
    if (remain > 0) cob += remain;
  }
  return cob;
}

/* ===== 색상 보간(차트 배경 컬러 변화 부드럽게) ===== */
function parseRgba(str){
  const m = str.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/i);
  if (!m) return {r:0,g:0,b:0,a:0};
  return { r:+m[1], g:+m[2], b:+m[3], a:+m[4] };
}
function lerp(a,b,t){ return a + (b-a)*t; }
function lerpColor(c1, c2, t){
  const a = parseRgba(c1), b = parseRgba(c2);
  const r = Math.round(lerp(a.r,b.r,t));
  const g = Math.round(lerp(a.g,b.g,t));
  const b2= Math.round(lerp(a.b,b.b,t));
  const a2= +lerp(a.a,b.a,t).toFixed(3);
  return `rgba(${r},${g},${b2},${a2})`;
}

/* ===== 배경 그래프 (라인 없이 하부 채움, 구간별 색) ===== */
const ZONE_COLORS = {
  red:   "rgba(255,92,92,0.34)",
  orange:"rgba(255,170,64,0.32)",
  green: "rgba(110,231,183,0.28)",
  red2:  "rgba(255,92,92,0.34)"
};

function zoneColor(bg){
  if (bg >= 40 && bg <= 70) return ZONE_COLORS.red;
  if (bg >= 71 && bg <= 90) return ZONE_COLORS.orange;
  if (bg >= 91 && bg <= 200) return ZONE_COLORS.green;
  if (bg >= 201 && bg <= 240) return ZONE_COLORS.orange;
  if (bg >= 241 && bg <= 401) return ZONE_COLORS.red2;
  return "rgba(255,92,92,0.28)";
}

let prevZoneColor = null;
let zoneAnim = { active:false, from:null, to:null, start:0, dur:600 };

function currentZoneColor(nowMs){
  if (!zoneAnim.active || !zoneAnim.from || !zoneAnim.to) return prevZoneColor || zoneAnim.to || "rgba(255,92,92,0.28)";
  const t = Math.min(1, (nowMs - zoneAnim.start) / zoneAnim.dur);
  const k = 1 - Math.pow(1 - t, 3);
  const c = lerpColor(zoneAnim.from, zoneAnim.to, k);
  if (t >= 1){
    zoneAnim.active = false;
    prevZoneColor = zoneAnim.to;
  }
  return c;
}

function startZoneColorTransition(next){
  if (!prevZoneColor){
    prevZoneColor = next;
    zoneAnim.active = false;
    return;
  }
  if (next === prevZoneColor) return;
  zoneAnim.active = true;
  zoneAnim.from = prevZoneColor;
  zoneAnim.to = next;
  zoneAnim.start = performance.now();
}

/* 슬라이드 포함 draw */
function drawAreaBackground(canvas, series, xOffsetPx){
  const ctx = canvas.getContext("2d");
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const cssW = window.innerWidth;
  const cssH = window.innerHeight;

  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);

  ctx.clearRect(0,0,cssW,cssH);
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,cssW,cssH);

  if (!series || series.length < 2) return;

  const padX = 10;
  const padY = 10;
  const w = cssW - padX*2;
  const h = cssH - padY*2;

  const xs = series.map(p=>p.t);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);

  const minY = 40;
  const maxY = 401;

  const xMap = (t) => padX + ((t - minX) / (maxX - minX)) * w + (xOffsetPx || 0);
  const yMap = (v) => padY + (1 - ((v - minY) / (maxY - minY))) * h;

  ctx.save();
  ctx.beginPath();
  ctx.rect(padX, padY, w, h);
  ctx.clip();

  const now = performance.now();
  const fallback = "rgba(255,92,92,0.28)";
  const zoneOverlayColor = currentZoneColor(now) || fallback;

  for (let i=0;i<series.length-1;i++){
    const p0 = series[i];
    const p1 = series[i+1];

    const x0 = xMap(p0.t);
    const x1 = xMap(p1.t);
    const y0 = yMap(p0.v);
    const y1 = yMap(p1.v);

    const mid = (p0.v + p1.v) / 2;
    ctx.fillStyle = zoneColor(mid);

    ctx.beginPath();
    ctx.moveTo(x0, h + padY);
    ctx.lineTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x1, h + padY);
    ctx.closePath();
    ctx.fill();
  }

  // 최근값 기준 “전체 톤” 오버레이를 얇게 덮어서 색 변화가 서서히 느껴지게
  ctx.fillStyle = zoneOverlayColor;
  ctx.globalAlpha = 0.22;
  ctx.fillRect(padX, padY, w, h);
  ctx.globalAlpha = 1;

  ctx.restore();

  const grad = ctx.createLinearGradient(0, 0, 0, cssH);
  grad.addColorStop(0, "rgba(0,0,0,0.76)");
  grad.addColorStop(0.35, "rgba(0,0,0,0.40)");
  grad.addColorStop(1, "rgba(0,0,0,0.12)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,cssW,cssH);
}

/* ===== 데이터 로드/렌더 ===== */
let cachedProfile = null;
let cachedEntries = null;
let cachedTreatments = null;

/* 실시간 경과시간용 */
let latestEntryMsForAge = null;

/* 롤용 상태 */
let lastBgValue = null;
let lastArrowText = null;

/* 그래프 슬라이드용 */
let prevGraphEndMs = null;
let lastSeriesForAnim = null;
let graphAnim = { active:false, from:0, to:0, start:0, dur:700 };

function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

function startGraphSlide(series, dx){
  lastSeriesForAnim = series;
  graphAnim.active = true;
  graphAnim.from = 0;
  graphAnim.to = dx;
  graphAnim.start = performance.now();
}

function tickGraph(){
  if (!lastSeriesForAnim) return;

  let x = 0;
  if (graphAnim.active){
    const now = performance.now();
    const t = Math.min(1, (now - graphAnim.start) / graphAnim.dur);
    const k = easeOutCubic(t);
    x = graphAnim.from + (graphAnim.to - graphAnim.from) * k;

    if (t >= 1){
      graphAnim.active = false;
      x = 0;
    }
  }

  drawAreaBackground(document.getElementById("bgCanvas"), lastSeriesForAnim, x);

  // 그래프 슬라이드가 끝나도, zone 컬러 트랜지션이 진행중이면 계속 리프레시
  if (graphAnim.active || zoneAnim.active){
    requestAnimationFrame(tickGraph);
  }
}

/* 공용 롤 애니메이터: 텍스트 바뀌면 up/down로 굴림 */
function rollText(stackId, oldId, newId, prevText, nextText, dir){
  const stack = document.getElementById(stackId);
  const oldEl = document.getElementById(oldId);
  const newEl = document.getElementById(newId);
  if (!stack || !oldEl || !newEl) return prevText;

  const resetTo = (text) => {
    stack.classList.remove("anim-up","anim-down");

    oldEl.textContent = text;
    newEl.textContent = text;

    // 항상 안전하게 초기화
    oldEl.style.transition = "none";
    newEl.style.transition = "none";
    oldEl.style.opacity = "1";
    newEl.style.opacity = "0";
    oldEl.style.transform = "translateY(0)";
    newEl.style.transform = "translateY(0)";

    // 다음 애니메이션을 위해 transition 복구
    requestAnimationFrame(() => {
      oldEl.style.transition = "";
      newEl.style.transition = "";
    });
  };

  // 첫 렌더 또는 값 같음: 애니메이션 없이 확정
  if (prevText === null || nextText === prevText){
    resetTo(nextText);
    return nextText;
  }

  // 애니메이션 준비
  oldEl.textContent = prevText;
  newEl.textContent = nextText;

  stack.classList.remove("anim-up","anim-down");

  // 시작 위치 세팅
  newEl.style.transition = "none";
  newEl.style.opacity = "0";
  newEl.style.transform = (dir === "up") ? "translateY(115%)" : "translateY(-115%)";

  oldEl.style.transition = "none";
  oldEl.style.opacity = "1";
  oldEl.style.transform = "translateY(0)";

  void stack.offsetWidth; // reflow

  newEl.style.transition = "";
  oldEl.style.transition = "";
  stack.classList.add(dir === "up" ? "anim-up" : "anim-down");

  window.setTimeout(() => {
    resetTo(nextText);
  }, 460);

  return nextText;
}

function setRollingBgAndArrow(nextBg, nextArrowText, nextArrowCls){
  const arrowWrap = document.getElementById("arrowWrap");

  // 방향은 혈당 변화 방향으로(요구: 플랫↔화살표 변화도 혈당과 같이 위/아래)
  let dir = "up";
  if (lastBgValue !== null && Number.isFinite(nextBg)){
    dir = nextBg > lastBgValue ? "up" : (nextBg < lastBgValue ? "down" : "up");
  }

  // BG 롤
  if (nextBg === null || !Number.isFinite(nextBg)){
    lastBgValue = null;
    rollText("numStackBg","bgOld","bgNew", lastBgValue, "--", "up");
  } else {
    const nextBgText = String(Math.round(nextBg));
    const prevBgText = (lastBgValue === null) ? null : String(Math.round(lastBgValue));
    rollText("numStackBg","bgOld","bgNew", prevBgText, nextBgText, dir);
    lastBgValue = nextBg;
  }

  // Arrow 롤(텍스트가 바뀔 때만)
  if (arrowWrap){
    arrowWrap.className = "arrow " + (nextArrowCls || "flat");
  }
  lastArrowText = rollText("numStackArrow","arrowOld","arrowNew", lastArrowText, nextArrowText, dir);
}

async function loadData(){
  const base = NS_BASE_URL.replace(/\/+$/,"");
  const profileUrl = withToken(`${base}/api/v1/profile.json`);
  const entriesUrl = withToken(`${base}/api/v1/entries/sgv.json?count=72`);
  const trUrl = withToken(`${base}/api/v1/treatments.json?count=200`);
  const [p,e,t] = await Promise.all([fetchJson(profileUrl), fetchJson(entriesUrl), fetchJson(trUrl)]);
  cachedProfile = p;
  cachedEntries = e;
  cachedTreatments = t;
}

function render(){
  const ageEl = document.getElementById("ageTxt");
  const chgEl = document.getElementById("chgTxt");
  const iobEl = document.getElementById("iobTxt");
  const cobEl = document.getElementById("cobTxt");

  if (!cachedEntries || !Array.isArray(cachedEntries) || cachedEntries.length === 0) return;

  const s = sortByTimeDesc(cachedEntries);
  const latest = s[0];
  const prev = s[1];

  const latestV = getSgv(latest);

  const { arrow, cls } = directionToArrow(latest?.direction);
  setRollingBgAndArrow(latestV, arrow, cls);

  const latestMs = safeNum(latest?.date, null);
  latestEntryMsForAge = latestMs;

  if (latestMs !== null){
    ageEl.textContent = formatAge(Date.now() - latestMs);
  } else {
    ageEl.textContent = "--:--";
  }

  const prevV = getSgv(prev);
  if (latestV !== null && prevV !== null){
    const d = latestV - prevV;
    const sign = d > 0 ? "+" : "";
    chgEl.textContent = sign + String(Math.round(d));
  } else {
    chgEl.textContent = "--";
  }

  const { dia, carbsHr } = cachedProfile ? getDiaAndCarbsHr(cachedProfile) : { dia:null, carbsHr:null };

  const iob = (Number.isFinite(dia) && dia > 0 && cachedTreatments && latestMs !== null)
    ? computeIOB(cachedTreatments, latestMs, dia)
    : null;

  const cob = (Number.isFinite(carbsHr) && carbsHr > 0 && cachedTreatments && latestMs !== null)
    ? computeCOB(cachedTreatments, latestMs, carbsHr)
    : null;

  iobEl.textContent = (iob !== null) ? iob.toFixed(2) : "--";
  cobEl.textContent = (cob !== null) ? cob.toFixed(1) : "--";

  const endT = (latestMs !== null) ? latestMs : Date.now();
  const startT = endT - 60*60*1000;

  const series = cachedEntries
    .filter(e => {
      const t = safeNum(e.date, null);
      const v = getSgv(e);
      return Number.isFinite(t) && v !== null && t >= startT && t <= endT;
    })
    .sort((a,b)=>safeNum(a.date,0)-safeNum(b.date,0))
    .map(e => ({ t: safeNum(e.date,0), v: getSgv(e) }))
    .filter(p => p.v !== null);

  lastSeriesForAnim = series;

  // 최신값 기준 zone 컬러 변화는 부드럽게
  const lastV = series.length ? series[series.length - 1].v : null;
  if (Number.isFinite(lastV)){
    startZoneColorTransition(zoneColor(lastV));
  }

  // 그래프 슬라이드: end가 전진한 만큼 왼쪽으로
  let dx = 0;
  if (Number.isFinite(prevGraphEndMs) && Number.isFinite(endT) && endT > prevGraphEndMs){
    const dt = endT - prevGraphEndMs;
    const windowMs = 60 * 60 * 1000;
    const w = window.innerWidth - 20; // padX*2
    dx = -w * (dt / windowMs);
  }
  prevGraphEndMs = endT;

  if (Math.abs(dx) < 1){
    drawAreaBackground(document.getElementById("bgCanvas"), series, 0);
  } else {
    startGraphSlide(series, dx);
  }

  if (graphAnim.active || zoneAnim.active){
    requestAnimationFrame(tickGraph);
  }
}

let updating = false;
async function refresh(){
  if (updating) return;
  updating = true;
  try{
    await loadData();
    render();
  }catch(e){
    console.warn("monitor refresh failed", e);
  }finally{
    updating = false;
  }
}

(function init(){
  refresh();

  /* 데이터는 30초마다 */
  setInterval(refresh, 30 * 1000);

  /* 경과시간은 1초마다 실시간 갱신 */
  setInterval(() => {
    const ageEl = document.getElementById("ageTxt");
    if (!ageEl) return;
    if (Number.isFinite(latestEntryMsForAge)) {
      ageEl.textContent = formatAge(Date.now() - latestEntryMsForAge);
    } else {
      ageEl.textContent = "--:--";
    }
  }, 1000);

  window.addEventListener("resize", () => { try{ render(); }catch(_){ } });
})();
</script>
</body>
</html>
